<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¤©æ°”åŠ©æ‰‹</title>
    <meta name="theme-color" content="#4a90e2">
    <meta name="description" content="An intelligent weather assistant powered by AI">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Weather AI">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="icon" href="/static/icon.png" type="image/png">
    <link rel="apple-touch-icon" href="/static/icon.png">
    <link rel="stylesheet" href="/static/style.css">
</head>

<body>
    <div class="container">
        <div class="header" id="headerSection">
            <div class="sparkle-icon" id="logoIcon">
                âœ¨
            </div>
            <h1 id="appTitle">AI å¤©æ°”åŠ©æ‰‹</h1>
        </div>
        <div class="location-info-container">
            <div class="location-info" role="status">è¯·è¾“å…¥åŸå¸‚åç§°æˆ–ç‚¹å‡»ğŸ“è·å–å½“å‰ä½ç½®</div>
            <div id="manualLocationContainer" class="manual-location-container">
                <input type="text" 
                       id="cityInput" 
                       placeholder="è¯·è¾“å…¥åŸå¸‚åç§°" 
                       class="city-input"
                       aria-label="åŸå¸‚åç§°è¾“å…¥æ¡†">
                <button id="submitCity" class="submit-city-btn" aria-label="æäº¤åŸå¸‚">
                    â¤
                </button>
                <button class="get-location-btn" id="getLocationBtn" aria-label="è·å–ä½ç½®">
                    ğŸ“
                </button>
            </div>
        </div>
        <div class="input-controls">
            <!-- Model Selection Radio Buttons -->
            <div class="model-selection-container">
                <div class="model-radio">
                    <input type="radio" id="geminiModel" name="model" value="gemini" checked>
                    <label for="geminiModel">Gemini</label>
                </div>
                <div class="model-radio">
                    <input type="radio" id="deepseekModel" name="model" value="deepseek">
                    <label for="deepseekModel">DeepSeek</label>
                </div>
            </div>
            <div class="search-bar-container">
                <input type="text" class="search-bar" placeholder="é—®ç‚¹ä»€ä¹ˆå§..." aria-label="æœç´¢è¾“å…¥æ¡†" id="queryInput">
                <button class="clear-search" aria-label="æ¸…é™¤æœç´¢" id="clearSearch">âœ•</button>
                <button class="search-icon" aria-label="æœç´¢" id="searchButton"></button>
            </div>
            <div class="example-queries">
                <span class="example-query" data-query="è¿™å‡ å¤©é€‚åˆæˆ·å¤–å•è½¦ğŸš´å—ï¼Ÿ" data-days="5">å•è½¦ğŸš´</span>
                <span class="example-query" data-query="æ˜å¤©ç©¿ä»€ä¹ˆè¡£æœğŸ‘—åˆé€‚ï¼Ÿ" data-days="2">ç©¿è¡£ğŸ‘—</span>
                <span class="example-query" data-query="æœªæ¥ä¸‰å¤©ä¼šä¸‹é›¨ğŸŒ§ï¸å—ï¼Ÿ" data-days="3">ä¸‹é›¨ğŸŒ§ï¸</span>
                <span class="example-query" data-query="è¿™å‘¨é€‚åˆå»æµ·è¾¹ğŸ–ï¸å—ï¼Ÿ" data-days="7">æµ·è¾¹ğŸ–ï¸</span>
                <span class="example-query" data-query="åå¤©è¦é™æ¸©ğŸ¥¶å—ï¼Ÿ" data-days="2">é™æ¸©ğŸ¥¶</span>
            </div>
            <div class="forecast-days-control">
                <label for="forecastDays">é¢„æµ‹å¤©æ•°:</label>
                <div class="forecast-days-slider-container">
                    <input type="range" id="forecastDays" min="1" max="14" value="5" class="forecast-days-slider"
                        aria-label="é¢„æµ‹å¤©æ•°é€‰æ‹©" />
                    <span class="forecast-days-value" id="forecastDaysValue">5</span>
                </div>
            </div>
        </div>
        <div id="reasoning-container" class="reasoning-container">
            <div class="reasoning-content"></div>
        </div>
        <div id="response-container" role="region" aria-live="polite">
        </div>
        <div id="followupSection" style="display: none;">
            <div class="followup-question">éœ€è¦è¿›ä¸€æ­¥äº†è§£ä»€ä¹ˆï¼Ÿ</div>
            <div class="search-bar-container">
                <input type="text" class="search-bar" placeholder="è¾“å…¥è¿½é—®å†…å®¹..." aria-label="è¿½é—®è¾“å…¥æ¡†" id="followupInput">
                <button class="search-icon" aria-label="æäº¤è¿½é—®" id="submitFollowup">â¤</button>
            </div>
        </div>
    </div>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        // console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch(error => {
                        console.error('ServiceWorker registration failed:', error);
                    });
            });
        }

        // ç¼“å­˜å¤©æ°”æ•°æ®å¹¶æ˜¾ç¤ºè¿½é—®æ¡† (Cache weather data and show followup)
        let cachedWeatherData = null;

        function showFollowup() {
            document.getElementById('followupSection').style.display = 'block';
            document.getElementById('followupInput').focus();
        }

        // å»¶è¿ŸåŠ è½½marked.js
        let markedLoaded = false;
        let markedLoadPromise = null;
        
        function loadMarked() {
            if (markedLoaded) {
                return Promise.resolve();
            }
            
            if (markedLoadPromise) {
                return markedLoadPromise;
            }
            
            markedLoadPromise = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = '/static/marked.min.js';
                script.onload = () => {
                    markedLoaded = true;
                    // é…ç½® marked.js
                    marked.use({
                        gfm: true,
                        breaks: true,
                        pedantic: false,
                        smartLists: true,
                        smartypants: true
                    });
                    resolve();
                };
                script.onerror = reject;
                document.body.appendChild(script);
            });
            
            return markedLoadPromise;
        }

        // ä¿®æ”¹showResponseå‡½æ•°
        async function showResponse(markdownText, isLoading = false) {
            const responseContainer = document.getElementById('response-container');
            if (!responseContainer) return;
            
            if (!responseContainer.style.display || responseContainer.style.display === 'none') {
                responseContainer.style.display = 'block';
                responseContainer.innerHTML = '';
            }

            if (!markdownText.trim()) {
                return;
            }

            try {
                // ç¡®ä¿marked.jså·²åŠ è½½
                await loadMarked();
                
                // ä½¿ç”¨marked.parseæ¸²æŸ“markdown
                const html = marked.parse(markdownText);
                responseContainer.innerHTML = html;
                
                // å¤„ç†ä»£ç å—
                const codeBlocks = responseContainer.querySelectorAll('pre code');
                if (codeBlocks.length > 0) {
                    codeBlocks.forEach(block => {
                        block.style.display = 'block';
                        block.style.whiteSpace = 'pre-wrap';
                        block.style.wordWrap = 'break-word';
                    });
                }
                
                // å¤„ç†å¼•ç”¨å—
                const blockquotes = responseContainer.querySelectorAll('blockquote');
                if (blockquotes.length > 0) {
                    blockquotes.forEach(quote => {
                        quote.style.borderLeft = '4px solid var(--primary-color)';
                        quote.style.paddingLeft = '1rem';
                        quote.style.margin = '1rem 0';
                        quote.style.color = 'inherit';
                    });
                }

                if (html.trim()) {
                    hideLoading();
                }

                const followupSection = document.getElementById('followupSection');
                if (followupSection) {
                    followupSection.style.display = 'block';
                }
            } catch (error) {
                console.error('Markdown æ¸²æŸ“é”™è¯¯:', error);
                responseContainer.innerHTML = `<p>æ¸²æŸ“é”™è¯¯: ${error.message}</p>`;
            }
        }

        function showLoading() {
            const searchIcon = document.querySelector('.search-icon');
            const container = document.querySelector('.container');
            if (searchIcon) {
                searchIcon.classList.add('loading');
            }
            if (container) {
                container.classList.add('loading');
            }
        }

        function hideLoading() {
            const searchIcon = document.querySelector('.search-icon');
            const container = document.querySelector('.container');
            if (searchIcon) {
                searchIcon.classList.remove('loading');
            }
            if (container) {
                container.classList.remove('loading');
            }
        }

        // ä¿®æ”¹æµå¼å“åº”å¤„ç†
        async function handleStreamResponse(response, onContent, onReasoning) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let accumulatedResponse = '';
            let accumulatedReasoning = '';
            let isFirstChunk = true;
            let modelType = document.querySelector('input[name="model"]:checked').value;
            
            // é¢„åŠ è½½marked.js
            try {
                await loadMarked();
            } catch (error) {
                console.error('åŠ è½½marked.jså¤±è´¥:', error);
                showResponse('åŠ è½½Markdownæ¸²æŸ“å™¨å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
                return;
            }
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;
                        
                        const data = line.slice(5).trim();
                        if (data === '[DONE]') {
                            hideLoading();
                            showFollowup();
                            continue;
                        }

                        try {
                            const jsonData = JSON.parse(data);
                            
                            if (jsonData.error) {
                                showResponse(`é”™è¯¯: ${jsonData.error}`);
                                hideLoading();
                                return;
                            }

                            // å¤„ç†å¼€å§‹ä¿¡å·
                            if (jsonData.start) {
                                accumulatedResponse = '';
                                isFirstChunk = true;
                                continue;
                            }

                            // ç»Ÿä¸€å¤„ç†å†…å®¹
                            if (jsonData.content) {
                                const content = jsonData.content;

                                // å¦‚æœæ˜¯ç¬¬ä¸€å—å†…å®¹ï¼Œæ¸…ç©ºä¹‹å‰çš„ç´¯ç§¯
                                if (isFirstChunk) {
                                    accumulatedResponse = '';
                                    isFirstChunk = false;
                                }
                                
                                // æ·»åŠ å†…å®¹åˆ°ç´¯ç§¯å“åº”
                                accumulatedResponse += content;

                                // å°è¯•æ¸²æŸ“markdown
                                try {
                                    const html = marked.parse(accumulatedResponse);
                                    const responseContainer = document.getElementById('response-container');
                                    if (responseContainer) {
                                        responseContainer.innerHTML = html;
                                        responseContainer.style.display = 'block';
                                        
                                        // ç»Ÿä¸€å¤„ç†æ ·å¼
                                        const codeBlocks = responseContainer.querySelectorAll('pre code');
                                        codeBlocks.forEach(block => {
                                            block.style.display = 'block';
                                            block.style.whiteSpace = 'pre-wrap';
                                            block.style.wordWrap = 'break-word';
                                        });

                                        const blockquotes = responseContainer.querySelectorAll('blockquote');
                                        blockquotes.forEach(quote => {
                                            quote.style.borderLeft = '4px solid var(--primary-color)';
                                            quote.style.paddingLeft = '1rem';
                                            quote.style.margin = '1rem 0';
                                            quote.style.color = 'inherit';
                                            quote.style.background = 'rgba(0, 0, 0, 0.03)';
                                            quote.style.borderRadius = '0 8px 8px 0';
                                            quote.style.padding = '1rem';
                                        });
                                    }
                                } catch (renderError) {
                                    console.warn('æ¸²æŸ“ä¸­é—´çŠ¶æ€å‡ºé”™ï¼Œç»§ç»­ç´¯ç§¯å†…å®¹:', renderError);
                                }
                            }

                            // ç»Ÿä¸€å¤„ç†æ¨ç†å†…å®¹
                            if (jsonData.reasoning_content) {
                                accumulatedReasoning += jsonData.reasoning_content;
                                onReasoning(accumulatedReasoning);
                            }
                        } catch (e) {
                            if (data !== '[DONE]') {
                                console.error('è§£ææ•°æ®å‡ºé”™:', e, 'data:', data);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('å¤„ç†æµå¼å“åº”æ—¶å‡ºé”™:', error);
                showResponse(`å¤„ç†å“åº”æ—¶å‡ºé”™: ${error.message}`);
            } finally {
                hideLoading();
                
                // æœ€åå†æ¸²æŸ“ä¸€æ¬¡ç¡®ä¿å†…å®¹å®Œæ•´
                if (accumulatedResponse) {
                    try {
                        // ç¡®ä¿marked.jså·²åŠ è½½
                        await loadMarked();
                        
                        // å¯¹äºGeminiï¼Œå°è¯•ä¿®å¤å¯èƒ½çš„Markdownæ ¼å¼é—®é¢˜
                        if (modelType === 'gemini') {
                            // ç¡®ä¿ä»£ç å—æ­£ç¡®é—­åˆ
                            const codeBlockMatches = accumulatedResponse.match(/```/g);
                            if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
                                accumulatedResponse += '\n```';
                            }
                            
                            // ç¡®ä¿è¡¨æ ¼æ ¼å¼æ­£ç¡®
                            if (accumulatedResponse.includes('|') && !accumulatedResponse.includes('|-')) {
                                accumulatedResponse = accumulatedResponse.replace(/\|([^|\n]+\|)+\n(?!\|[-:]+\|)/g, (match) => {
                                    const columnCount = (match.match(/\|/g) || []).length - 1;
                                    const separator = '\n|' + '---|'.repeat(columnCount) + '\n';
                                    return match.replace('\n', separator);
                                });
                            }
                        }
                        
                        const html = marked.parse(accumulatedResponse);
                        const responseContainer = document.getElementById('response-container');
                        if (responseContainer) {
                            responseContainer.innerHTML = html;
                            responseContainer.style.display = 'block';
                            
                            // æœ€ç»ˆæ ·å¼å¤„ç†
                            const codeBlocks = responseContainer.querySelectorAll('pre code');
                            codeBlocks.forEach(block => {
                                block.style.display = 'block';
                                block.style.whiteSpace = 'pre-wrap';
                                block.style.wordWrap = 'break-word';
                            });

                            const blockquotes = responseContainer.querySelectorAll('blockquote');
                            blockquotes.forEach(quote => {
                                quote.style.borderLeft = '4px solid var(--primary-color)';
                                quote.style.paddingLeft = '1rem';
                                quote.style.margin = '1rem 0';
                                quote.style.color = 'inherit';
                                quote.style.background = 'rgba(0, 0, 0, 0.03)';
                                quote.style.borderRadius = '0 8px 8px 0';
                                quote.style.padding = '1rem';
                            });
                        }
                    } catch (finalRenderError) {
                        console.error('æœ€ç»ˆæ¸²æŸ“é”™è¯¯:', finalRenderError);
                        showResponse(`æ¸²æŸ“é”™è¯¯: ${finalRenderError.message}`);
                    }
                }
            }
        }

        // æ£€æŸ¥markdownæ˜¯å¦å®Œæ•´
        function isCompleteMarkdown(text) {
            // æ£€æŸ¥åŸºæœ¬çš„markdownç»“æ„æ˜¯å¦å®Œæ•´
            const patterns = {
                codeBlock: /```[\s\S]*?```/g,
                blockquote: /^>[\s\S]*?\n\n/gm,
                list: /^[-*+][\s\S]*?\n\n/gm,
                heading: /^#{1,6}.*?\n/gm,
                table: /\|.*\|.*\n\|[-:| ]*\|.*\n(\|.*\|.*\n)*/gm,
            };

            // æ£€æŸ¥æ˜¯å¦æœ‰æœªé—­åˆçš„ä»£ç å—
            const codeBlockMatches = text.match(/```/g);
            if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„å¥å­ï¼ˆä»¥æ ‡ç‚¹ç¬¦å·ç»“å°¾ï¼‰
            const lastChar = text.trim().slice(-1);
            const completionChars = ['.', 'ã€‚', '!', 'ï¼', '?', 'ï¼Ÿ', 'â€¦', '"', "'", 'ã€', 'ï¼‰', 'ã€‘', 'ã€‹', 'ï¼›', ';'];
            if (!completionChars.includes(lastChar)) {
                return false;
            }

            return true;
        }

        // ä¿®æ”¹getWeatherAIResponseå‡½æ•°
        async function getWeatherAIResponse(lat, lon, query, forecastDays) {
            try {
                showLoading();
                showResponse('', false); // æ¸…ç©ºä¹‹å‰çš„å“åº”
                const modelType = document.querySelector('input[name="model"]:checked').value;
                
                const response = await fetch('/get_weather_advice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        latitude: lat,
                        longitude: lon,
                        query: query,
                        forecast_days: forecastDays,
                        model_type: modelType
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // å¤„ç†æµå¼å“åº”
                await handleStreamResponse(
                    response,
                    (content) => showResponse(content, true),
                    (reasoning) => showReasoning(reasoning)
                );

                // ç¼“å­˜å¤©æ°”æ•°æ®
                cachedWeatherData = {
                    latitude: lat,
                    longitude: lon,
                    query: query,
                    forecast_days: forecastDays
                };

            } catch (error) {
                console.error('è·å–å¤©æ°”å»ºè®®å¤±è´¥:', error);
                showResponse(`è·å–å¤©æ°”å»ºè®®å¤±è´¥: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // ä¿®æ”¹handleFollowupå‡½æ•°
        async function handleFollowup() {
            const query = document.getElementById('followupInput').value.trim();
            if (!query) {
                showResponse("è¯·è¾“å…¥è¿½é—®å†…å®¹ã€‚");
                return;
            }
            if (!cachedWeatherData) {
                showResponse("è¯·å…ˆè¿›è¡Œå¤©æ°”æŸ¥è¯¢ã€‚");
                return;
            }
            
            try {
                showLoading();
                showResponse('', false);
                const modelType = document.querySelector('input[name="model"]:checked').value;
                
                const response = await fetch('/ask_followup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latitude: cachedWeatherData.latitude,
                        longitude: cachedWeatherData.longitude,
                        forecast_days: cachedWeatherData.forecast_days,
                        query: query,
                        model_type: modelType
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                await handleStreamResponse(
                    response,
                    () => {}, // ç©ºå‡½æ•°ï¼Œå› ä¸ºæ¸²æŸ“å·²ç»åœ¨ handleStreamResponse ä¸­å¤„ç†
                    (reasoning) => showReasoning(reasoning)
                );
            } catch (error) {
                console.error('è¿½é—®è¯·æ±‚å¤±è´¥:', error);
                showResponse(`è¿½é—®å¤±è´¥: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const body = document.body;
            const locationInfo = document.querySelector('.location-info');
            const reacquireLocationButton = document.getElementById('reacquire-location');
            const searchBar = document.querySelector('.search-bar');
            const searchButton = document.getElementById('searchButton');
            const responseContainer = document.getElementById('response-container');
            const forecastDaysInput = document.getElementById('forecastDays');
            const forecastDaysValueDisplay = document.getElementById('forecastDaysValue');
            const exampleQueries = document.querySelectorAll('.example-query');

            let latitude;
            let longitude;

            const THEMES = {
                LIGHT: 'light',
                DARK: 'dark'
            };

            const LOCATION_MESSAGES = {
                LOADING: 'æ­£åœ¨è·å–ä½ç½®ä¿¡æ¯...',
                DENIED: 'ä½ç½®ä¿¡æ¯è®¿é—®è¢«æ‹’ç»ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥åŸå¸‚',
                ERROR: 'æ— æ³•è·å–æ‚¨çš„ä½ç½®ä¿¡æ¯ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥åŸå¸‚',
                UNSUPPORTED: 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®åŠŸèƒ½ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥åŸå¸‚'
            };

            function setTheme(theme) {
                body.classList.toggle('dark-mode', theme === THEMES.DARK);
                localStorage.setItem('theme', theme);
            }

            // Apply Automatic Theme on Load
            function applyAutomaticTheme() {
                const hour = new Date().getHours();
                const theme = (hour >= 19 || hour < 7) ? THEMES.DARK : THEMES.LIGHT;
                setTheme(theme);
            }

            // Initialize theme (Apply saved or automatic theme)
            const savedTheme = localStorage.getItem('theme');
            savedTheme ? setTheme(savedTheme) : applyAutomaticTheme();

            // æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦åˆ‡æ¢ä¸»é¢˜
            setInterval(() => {
                if (!localStorage.getItem('theme')) {  // åªæœ‰åœ¨æ²¡æœ‰æ‰‹åŠ¨è®¾ç½®ä¸»é¢˜æ—¶æ‰è‡ªåŠ¨åˆ‡æ¢
                    applyAutomaticTheme();
                }
            }, 3600000); // æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡

            let cachedLocation = {};
            let cachedForecastDays = 5;

            function getLocation() {
                locationInfo.textContent = LOCATION_MESSAGES.LOADING;
                if (navigator.geolocation) {
                    const geolocationOptions = {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    };

                    navigator.geolocation.getCurrentPosition(
                        // Success callback
                        (position) => {
                            latitude = position.coords.latitude;
                            longitude = position.coords.longitude;
                            locationInfo.textContent = `æ‚¨çš„ä½ç½®ï¼š ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                            currentLat = latitude;
                            currentLon = longitude;
                        },
                        // Error callback
                        (error) => {
                            console.error('åœ°ç†ä½ç½®é”™è¯¯:', error);
                            locationInfo.textContent = {
                                [GeolocationPositionError.PERMISSION_DENIED]: LOCATION_MESSAGES.DENIED,
                                [GeolocationPositionError.TIMEOUT]: LOCATION_MESSAGES.ERROR,
                                [GeolocationPositionError.POSITION_UNAVAILABLE]: LOCATION_MESSAGES.ERROR,
                            }[error.code] || LOCATION_MESSAGES.ERROR;
                            showManualLocationInput();
                        },
                        geolocationOptions
                    );
                } else {
                    locationInfo.textContent = LOCATION_MESSAGES.UNSUPPORTED;
                    showManualLocationInput();
                }
            }

            function handleSearch() {
                const query = document.getElementById('queryInput').value.trim();
                if (!query) {
                    showResponse("è¯·è¾“å…¥ä¸€ä¸ªé—®é¢˜ã€‚");
                    return;
                }
                if (typeof latitude === 'undefined' || typeof longitude === 'undefined') {
                    showResponse("ä½ç½®ä¿¡æ¯å°šæœªå¯ç”¨ï¼Œè¯·ç¨å€™ã€‚");
                    return;
                }
                // ç¼“å­˜ä½ç½®å’Œé¢„æµ‹å¤©æ•° (Cache location and forecast days)
                cachedLocation = { latitude, longitude };
                cachedForecastDays = parseInt(forecastDaysInput.value);
                getWeatherAIResponse(latitude, longitude, query, cachedForecastDays);
            }

            // Event Listeners
            searchButton.addEventListener('click', handleSearch); // Attach to search button
            searchBar.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') handleSearch();
            });
            document.getElementById('getLocationBtn').addEventListener('click', () => {
                // Clear any existing location info
                locationInfo.textContent = LOCATION_MESSAGES.LOADING;
                // Reset the location values
                latitude = undefined;
                longitude = undefined;
                // Start the location process again
                getLocation();
            });

            // Example queries event listeners (Updated)
            exampleQueries.forEach(queryElement => {
                queryElement.addEventListener('click', function () {
                    searchBar.value = this.dataset.query;
                    searchBar.focus();
                    const days = this.dataset.days;
                    if (days) {
                        forecastDaysInput.value = days;
                        forecastDaysValueDisplay.textContent = days;
                        updateSliderBackground(forecastDaysInput);
                    }
                    // åªæœ‰åœ¨æœ‰å†…å®¹æ—¶æ‰æ˜¾ç¤ºæ¸…é™¤æŒ‰é’®
                    clearButton.classList.toggle('visible', searchBar.value.length > 0);
                });
            });

            // Forecast days slider (Slider functionality with visual update)
            function updateSliderBackground(slider) {
                const value = (slider.value - slider.min) / (slider.max - slider.min) * 100;
                slider.style.background = `linear-gradient(to right, var(--primary-color) 0%, var(--primary-color) ${value}%, #d3d3d3 ${value}%, #d3d3d3 100%)`;
            }

            forecastDaysInput.addEventListener('input', () => {
                forecastDaysValueDisplay.textContent = forecastDaysInput.value;
                updateSliderBackground(forecastDaysInput); // Update slider background on input
            });
            updateSliderBackground(forecastDaysInput); // Initial slider background update

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    searchBar.focus();
                }
            });

            // Add error boundary
            window.onerror = function (msg, url, lineNo, columnNo, error) {
                console.error('Global error:', { msg, url, lineNo, columnNo, error });
                showResponse('åº”ç”¨ç¨‹åºå‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
                return false;
            };

            // Add analytics event tracking (optional - replace with your analytics code)
            const trackEvent = (eventName, eventData) => {
                if (window.gtag) {
                    gtag('event', eventName, eventData);
                }
            };

            // Add accessibility improvements
            const improveAccessibility = () => {
                // Add ARIA labels - already in place, can add more if needed
            };

            improveAccessibility();

            // Lazy load response container (Intersection Observer)
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1'; // Or any other lazy load effect
                        observer.unobserve(entry.target); // Optionally unobserve after loading
                    }
                });
            });

            if (responseContainer) {
                responseContainer.style.opacity = '0'; // Initially hide or style for lazy load
                observer.observe(responseContainer);
            }

            // Prefers reduced motion
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.documentElement.style.setProperty('--transition-speed', '0s');
            }

            // Add this to your existing JavaScript
            const searchInput = document.getElementById('queryInput');
            const clearButton = document.getElementById('clearSearch');

            // Show/hide clear button based on input content
            searchInput.addEventListener('input', () => {
                clearButton.classList.toggle('visible', searchInput.value.length > 0);
            });

            // Clear input when clear button is clicked
            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                clearButton.classList.remove('visible');
                searchInput.focus();
            });

            // ç¡®ä¿é¡µé¢åŠ è½½æ—¶æ¸…é™¤æŒ‰é’®æ˜¯éšè—çš„
            document.addEventListener('DOMContentLoaded', () => {
                clearButton.classList.remove('visible');
            });

            // æ·»åŠ æ‰‹åŠ¨ä½ç½®è¾“å…¥ç›¸å…³å‡½æ•°
            function showManualLocationInput() {
                const container = document.getElementById('manualLocationContainer');
                if (container) {
                    container.style.display = 'flex';
                }
            }

            function hideManualLocationInput() {
                const container = document.getElementById('manualLocationContainer');
                if (container) {
                    container.style.display = 'none';
                }
            }

            // ä¿®æ”¹handleCitySubmitå‡½æ•°
            async function handleCitySubmit() {
                const cityInput = document.getElementById('cityInput');
                const city = cityInput.value.trim();
                
                if (!city) {
                    locationInfo.textContent = 'è¯·è¾“å…¥åŸå¸‚åç§°';
                    return;
                }

                try {
                    showLoading();
                    locationInfo.textContent = 'æ­£åœ¨è·å–åŸå¸‚ä½ç½®ä¿¡æ¯...';
                    const response = await fetch('/get_city_location', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ city: city })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }

                    latitude = parseFloat(data.latitude);
                    longitude = parseFloat(data.longitude);
                    currentLat = latitude;
                    currentLon = longitude;
                    
                    locationInfo.textContent = `æ‚¨çš„ä½ç½®ï¼š ${latitude.toFixed(4)}, ${longitude.toFixed(4)} (${city})`;
                    cityInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†ï¼Œæ–¹ä¾¿ä¸‹æ¬¡è¾“å…¥
                } catch (error) {
                    console.error('è·å–åŸå¸‚ä½ç½®å¤±è´¥:', error);
                    locationInfo.textContent = `æ— æ³•è·å–åŸå¸‚"${city}"çš„ä½ç½®ä¿¡æ¯ï¼Œè¯·é‡è¯•æˆ–è¾“å…¥å…¶ä»–åŸå¸‚`;
                } finally {
                    hideLoading();
                }
            }

            // æ·»åŠ åŸå¸‚æäº¤ç›¸å…³çš„äº‹ä»¶ç›‘å¬
            document.getElementById('submitCity').addEventListener('click', handleCitySubmit);
            document.getElementById('cityInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleCitySubmit();
            });
            document.getElementById('getLocationBtn').addEventListener('click', getLocation);

            // ç»‘å®šè¿½é—®æŒ‰é’®äº‹ä»¶ (Bind followup button event)
            document.getElementById('submitFollowup').addEventListener('click', handleFollowup);
            document.getElementById('followupInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleFollowup();
            });

            // æ·»åŠ æ ‡é¢˜å’Œlogoçš„ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
            const headerSection = document.getElementById('headerSection');
            const logoIcon = document.getElementById('logoIcon');
            const appTitle = document.getElementById('appTitle');

            function refreshPage() {
                window.location.reload();
            }

            // ä¸ºæ•´ä¸ªheaderåŒºåŸŸæ·»åŠ å¯ç‚¹å‡»çš„æ ·å¼
            headerSection.style.cursor = 'pointer';
            logoIcon.style.cursor = 'pointer';
            appTitle.style.cursor = 'pointer';

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
            headerSection.addEventListener('click', refreshPage);
            logoIcon.addEventListener('click', refreshPage);
            appTitle.addEventListener('click', refreshPage);
        });

        function showReasoning(content) {
            const reasoningContainer = document.getElementById('reasoning-container');
            const reasoningContent = reasoningContainer.querySelector('.reasoning-content');
            
            if (content) {
                reasoningContainer.style.display = 'block';
                
                // ä¿æŒæœ€å6è¡Œï¼Œå¢åŠ æ˜¾ç¤ºå†…å®¹
                const lines = content.split('\n');
                if (lines.length > 6) {
                    reasoningContent.textContent = lines.slice(-6).join('\n');
                } else {
                    reasoningContent.textContent = content;
                }

                // å–æ¶ˆä¹‹å‰çš„åŠ¨ç”»
                if (reasoningContainer.scrollTimeout) {
                    clearTimeout(reasoningContainer.scrollTimeout);
                }
                if (reasoningContainer.animationFrameId) {
                    cancelAnimationFrame(reasoningContainer.animationFrameId);
                }

                // ä½¿ç”¨ requestAnimationFrame å®ç°å¹³æ»‘æ»šåŠ¨
                const animate = () => {
                    const currentScroll = reasoningContainer.scrollTop;
                    const lineHeight = parseInt(getComputedStyle(reasoningContent).lineHeight);
                    const containerHeight = reasoningContainer.clientHeight;
                    const contentHeight = reasoningContent.scrollHeight;
                    
                    // åŠ¨æ€è°ƒæ•´ç¼“å†²åŒºå¤§å°ï¼ŒåŸºäºå†…å®¹é•¿åº¦
                    const bufferSize = Math.min(
                        lineHeight * 2,
                        (contentHeight - containerHeight) * 0.2
                    );
                    
                    const targetScroll = contentHeight - containerHeight - bufferSize;
                    
                    if (targetScroll > currentScroll) {
                        // åŠ¨æ€è°ƒæ•´æ»šåŠ¨é€Ÿåº¦ï¼ŒåŸºäºå‰©ä½™æ»šåŠ¨è·ç¦»
                        const remainingDistance = targetScroll - currentScroll;
                        const speedFactor = Math.min(0.2, remainingDistance / contentHeight);
                        const scrollStep = Math.max(
                            1,
                            remainingDistance * speedFactor
                        );
                        
                        const maxStep = lineHeight * 0.8;
                        const actualStep = Math.min(scrollStep, maxStep);
                        
                        reasoningContainer.scrollTop = currentScroll + actualStep;
                        
                        if (Math.abs(targetScroll - (currentScroll + actualStep)) > 1) {
                            reasoningContainer.scrollTimeout = setTimeout(() => {
                                reasoningContainer.animationFrameId = requestAnimationFrame(animate);
                            }, 25); // é™ä½æ›´æ–°é¢‘ç‡ï¼Œå‡å°‘æ€§èƒ½å‹åŠ›
                        }
                    }
                };

                // å¯åŠ¨åŠ¨ç”»
                reasoningContainer.animationFrameId = requestAnimationFrame(animate);
            } else {
                reasoningContainer.style.display = 'none';
            }
        }
    </script>
</body>

</html>
