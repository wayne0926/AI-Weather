<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å¤©æ°”åŠ©æ‰‹</title>
    <meta name="theme-color" content="#4a90e2">
    <meta name="description" content="An intelligent weather assistant powered by AI">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Weather AI">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="icon" href="/static/icon.png" type="image/png">
    <link rel="apple-touch-icon" href="/static/icon.png">
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
</head>

<body>
    <button class="theme-toggle" id="theme-toggle" aria-label="åˆ‡æ¢ä¸»é¢˜">
        ğŸŒ™
    </button>
    <div class="container">
        <div class="header">
            <div class="sparkle-icon">
                âœ¨
            </div>
            <h1>AI å¤©æ°”åŠ©æ‰‹</h1>
        </div>
        <div class="location-info-container">
            <div class="location-info" role="status">è¯·è¾“å…¥åŸå¸‚åç§°æˆ–ç‚¹å‡»ğŸ“è·å–å½“å‰ä½ç½®</div>
            <div id="manualLocationContainer" class="manual-location-container">
                <input type="text" 
                       id="cityInput" 
                       placeholder="è¯·è¾“å…¥æ‚¨æ‰€åœ¨çš„åŸå¸‚åç§°" 
                       class="city-input"
                       aria-label="åŸå¸‚åç§°è¾“å…¥æ¡†">
                <button id="submitCity" class="submit-city-btn" aria-label="æäº¤åŸå¸‚">
                    â¤
                </button>
                <button class="get-location-btn" id="getLocationBtn" aria-label="è·å–ä½ç½®">
                    ğŸ“
                </button>
            </div>
        </div>
        <div class="input-controls">
            <!-- Model Selection Radio Buttons -->
            <div class="model-selection-container">
                <div class="model-radio">
                    <input type="radio" id="geminiModel" name="model" value="gemini" checked>
                    <label for="geminiModel">Gemini</label>
                </div>
                <div class="model-radio">
                    <input type="radio" id="deepseekModel" name="model" value="deepseek">
                    <label for="deepseekModel">DeepSeek</label>
                </div>
            </div>
            <div class="search-bar-container">
                <input type="text" class="search-bar" placeholder="é—®ç‚¹ä»€ä¹ˆå§..." aria-label="æœç´¢è¾“å…¥æ¡†" id="queryInput">
                <button class="clear-search" aria-label="æ¸…é™¤æœç´¢" id="clearSearch">âœ•</button>
                <button class="search-icon" aria-label="æœç´¢" id="searchButton">ğŸ”</button>
            </div>
            <div class="example-queries">
                <span class="example-query" data-query="è¿™å‡ å¤©é€‚åˆæˆ·å¤–å•è½¦ğŸš´å—ï¼Ÿ" data-days="5">å•è½¦ğŸš´</span>
                <span class="example-query" data-query="æ˜å¤©ç©¿ä»€ä¹ˆè¡£æœğŸ‘—åˆé€‚ï¼Ÿ" data-days="2">ç©¿è¡£ğŸ‘—</span>
                <span class="example-query" data-query="æœªæ¥ä¸‰å¤©ä¼šä¸‹é›¨ğŸŒ§ï¸å—ï¼Ÿ" data-days="3">ä¸‹é›¨ğŸŒ§ï¸</span>
                <span class="example-query" data-query="è¿™å‘¨é€‚åˆå»æµ·è¾¹ğŸ–ï¸å—ï¼Ÿ" data-days="7">æµ·è¾¹ğŸ–ï¸</span>
                <span class="example-query" data-query="åå¤©è¦é™æ¸©ğŸ¥¶å—ï¼Ÿ" data-days="2">é™æ¸©ğŸ¥¶</span>
            </div>
            <div class="forecast-days-control">
                <label for="forecastDays">é¢„æµ‹å¤©æ•°:</label>
                <div class="forecast-days-slider-container">
                    <input type="range" id="forecastDays" min="1" max="14" value="5" class="forecast-days-slider"
                        aria-label="é¢„æµ‹å¤©æ•°é€‰æ‹©" />
                    <span class="forecast-days-value" id="forecastDaysValue">5</span>
                </div>
            </div>
        </div>
        <!-- Add this HTML inside the container, before the response-container -->
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <span class="loading-text">æ­£åœ¨æ€è€ƒä¸­</span>
        </div>
        <div id="response-container" role="region" aria-live="polite">
        </div>
        <div id="followupSection" style="display: none;">
            <div class="followup-question">éœ€è¦è¿›ä¸€æ­¥äº†è§£ä»€ä¹ˆï¼Ÿ</div>
            <div class="search-bar-container">
                <input type="text" class="search-bar" placeholder="è¾“å…¥è¿½é—®å†…å®¹..." aria-label="è¿½é—®è¾“å…¥æ¡†" id="followupInput">
                <button class="search-icon" aria-label="æäº¤è¿½é—®" id="submitFollowup">â¤</button>
            </div>
        </div>
    </div>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch(error => {
                        console.error('ServiceWorker registration failed:', error);
                    });
            });
        }

        // ç¼“å­˜å¤©æ°”æ•°æ®å¹¶æ˜¾ç¤ºè¿½é—®æ¡† (Cache weather data and show followup)
        let cachedWeatherData = null;

        function showFollowup() {
            document.getElementById('followupSection').style.display = 'block';
            document.getElementById('followupInput').focus();
        }

        // å¤„ç†è¿½é—®è¾“å…¥ (Handle followup input)
        document.getElementById('followupInput').addEventListener('keypress', async function (e) {
            if (e.key === 'Enter') {
                const question = this.value.trim();
                if (question && cachedWeatherData) {
                    try {
                        showLoading(); // Show loading animation before request
                        const responseContainer = document.getElementById('response-container');
                        responseContainer.innerHTML = ''; // Clear previous response
                        const modelType = document.querySelector('input[name="model"]:checked').value; // Get selected model

                        const response = await fetch('/ask_followup', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: question,
                                latitude: cachedWeatherData.latitude,
                                longitude: cachedWeatherData.longitude,
                                forecast_days: cachedWeatherData.forecast_days,
                                model_type: modelType // Send model_type to backend
                            })
                        });

                        const data = await response.json();
                        if (data.ai_response) {
                            responseContainer.innerHTML = marked.parse(data.ai_response);
                            this.value = '';
                            window.scrollTo({
                                top: document.body.scrollHeight,
                                behavior: 'smooth'
                            });
                        }
                    } catch (error) {
                        console.error('è¿½é—®è¯·æ±‚å¤±è´¥:', error);
                        document.getElementById('response-container').innerHTML = 'è¿½é—®å¤±è´¥ï¼Œè¯·ç¨åå†è¯•';
                    } finally {
                        hideLoading(); // Hide loading animation after request (success or error)
                    }
                }
            }
        });

        // åœ¨åŸæœ‰è·å–å¤©æ°”æˆåŠŸçš„å›è°ƒä¸­æ·»åŠ ç¼“å­˜ (Add caching in the original success callback for weather retrieval)
        async function getWeatherAdvice() {
            try {
                const response = await fetch('/get_weather_advice', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        latitude: currentLat, // Make sure currentLat is defined or use latitude
                        longitude: currentLon, // Make sure currentLon is defined or use longitude
                        query: document.getElementById('queryInput').value, // Make sure queryInput id is correct or use searchBar.value
                        model_type: document.querySelector('input[name="model"]:checked').value // Send model_type to backend
                    })
                });

                const data = await response.json();
                if (data.ai_response) {
                    cachedWeatherData = data; // ç¼“å­˜åŸå§‹æ•°æ® (Cache original data)
                    document.getElementById('response-container').innerHTML = marked.parse(data.ai_response); // Make sure 'result' id exists, maybe use 'response-container' instead?
                    showFollowup();
                }
            } catch (error) {
                console.error('è¯·æ±‚å¤±è´¥:', error);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const body = document.body;
            const themeToggle = document.getElementById('theme-toggle');
            const locationInfo = document.querySelector('.location-info');
            const reacquireLocationButton = document.getElementById('reacquire-location');
            const searchBar = document.querySelector('.search-bar');
            const searchButton = document.getElementById('searchButton'); // Get search button
            const responseContainer = document.getElementById('response-container');
            const forecastDaysInput = document.getElementById('forecastDays');
            const forecastDaysValueDisplay = document.getElementById('forecastDaysValue');
            const exampleQueries = document.querySelectorAll('.example-query');

            let latitude;
            let longitude;

            const THEMES = {
                LIGHT: 'light',
                DARK: 'dark'
            };

            const LOCATION_MESSAGES = {
                LOADING: 'æ­£åœ¨è·å–ä½ç½®ä¿¡æ¯...',
                IP_LOADING: 'æ­£åœ¨é€šè¿‡ IP è·å–ä½ç½®ä¿¡æ¯...',
                DENIED: 'ä½ç½®ä¿¡æ¯è®¿é—®è¢«æ‹’ç»ã€‚æ­£åœ¨å°è¯•é€šè¿‡ IP ç¡®å®šä½ç½®ä¿¡æ¯...',
                ERROR: 'æ— æ³•è·å–æ‚¨çš„ä½ç½®ä¿¡æ¯ã€‚æ­£åœ¨å°è¯•é€šè¿‡ IP ç¡®å®šä½ç½®ä¿¡æ¯...',
                UNSUPPORTED: 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®åŠŸèƒ½ã€‚æ­£åœ¨å°è¯•é€šè¿‡ IP ç¡®å®šä½ç½®ä¿¡æ¯...'
            };

            function setTheme(theme) {
                body.classList.toggle('dark-mode', theme === THEMES.DARK);
                themeToggle.textContent = theme === THEMES.DARK ? 'â˜€ï¸' : 'ğŸŒ™';
                localStorage.setItem('theme', theme);
            }

            // Simplified Theme Toggle Function
            function toggleTheme() {
                setTheme(body.classList.contains('dark-mode') ? THEMES.LIGHT : THEMES.DARK);
            }

            // Apply Automatic Theme on Load (using simplified setTheme)
            function applyAutomaticTheme() {
                const hour = new Date().getHours();
                const theme = (hour >= 19 || hour < 7) ? THEMES.DARK : THEMES.LIGHT;
                setTheme(theme);
            }

            let cachedLocation = {};
            let cachedForecastDays = 5;

            function showResponse(markdownText, isLoading = false) {
                responseContainer.style.display = 'block';
                responseContainer.innerHTML = marked.parse(markdownText);
                document.getElementById('followupSection').style.display = 'block';
                window.scrollTo({
                    top: document.body.scrollHeight,
                    behavior: 'smooth'
                });
            }

            function handleFollowup() {
                const query = document.getElementById('followupInput').value.trim();
                if (!query) {
                    showResponse("è¯·è¾“å…¥è¿½é—®å†…å®¹ã€‚");
                    return;
                }
                // ä½¿ç”¨ç¼“å­˜æ•°æ®å‘èµ·è¿½é—®è¯·æ±‚ (Use cached data to initiate followup request)
                try {
                    showLoading(); // Show loading animation before request
                    showResponse('', false); // Clear previous response, set isLoading to false as loading is handled by dedicated container
                    const modelType = document.querySelector('input[name="model"]:checked').value; // Get selected model
                    fetch('/ask_followup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            latitude: cachedLocation.latitude,
                            longitude: cachedLocation.longitude,
                            forecast_days: cachedForecastDays,
                            query: query,
                            model_type: modelType // Send model_type for followup
                        })
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.ai_response) {
                                showResponse(data.ai_response);
                            } else {
                                showResponse(data.error || 'è¿½é—®å¤„ç†å¤±è´¥');
                            }
                        })
                        .finally(() => {
                            hideLoading(); // Hide loading animation after request (success or error)
                        });
                } catch (error) {
                    console.error('è¿½é—®è¯·æ±‚å¤±è´¥:', error);
                    showResponse(`è¿½é—®å¤±è´¥: ${error.message}`);
                    hideLoading(); // Hide loading animation in case of error
                }
            }

            // ç»‘å®šè¿½é—®æŒ‰é’®äº‹ä»¶ (Bind followup button event)
            document.getElementById('submitFollowup').addEventListener('click', handleFollowup);
            document.getElementById('followupInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleFollowup();
            });

            function getLocation() {
                locationInfo.textContent = LOCATION_MESSAGES.LOADING;
                let retryCount = 0;
                const MAX_RETRIES = 3;

                function tryGeolocation() {
                    if (navigator.geolocation) {
                        const geolocationOptions = {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 0
                        };

                        navigator.geolocation.getCurrentPosition(
                            // Success callback
                            (position) => {
                                latitude = position.coords.latitude;
                                longitude = position.coords.longitude;
                                locationInfo.textContent = `æ‚¨çš„ä½ç½®ï¼š ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                                currentLat = latitude;
                                currentLon = longitude;
                            },
                            // Error callback
                            (error) => {
                                console.error(`åœ°ç†ä½ç½®é”™è¯¯ (å°è¯• ${retryCount + 1}/${MAX_RETRIES}):`, error);
                                if (retryCount < MAX_RETRIES - 1) {
                                    retryCount++;
                                    locationInfo.textContent = `æ­£åœ¨é‡è¯•è·å–ä½ç½® (${retryCount}/${MAX_RETRIES})...`;
                                    setTimeout(tryGeolocation, 1000); // 1ç§’åé‡è¯•
                                } else {
                                    locationInfo.textContent = {
                                        [GeolocationPositionError.PERMISSION_DENIED]: LOCATION_MESSAGES.DENIED,
                                        [GeolocationPositionError.TIMEOUT]: LOCATION_MESSAGES.ERROR,
                                        [GeolocationPositionError.POSITION_UNAVAILABLE]: LOCATION_MESSAGES.ERROR,
                                    }[error.code] || LOCATION_MESSAGES.ERROR;
                                    tryIPLocation(); // åœ°ç†ä½ç½®å…¨éƒ¨å¤±è´¥åå°è¯•IPå®šä½
                                }
                            },
                            geolocationOptions
                        );
                    } else {
                        locationInfo.textContent = LOCATION_MESSAGES.UNSUPPORTED;
                        tryIPLocation(); // æµè§ˆå™¨ä¸æ”¯æŒæ—¶å°è¯•IPå®šä½
                    }
                }

                async function tryIPLocation() {
                    let ipRetryCount = 0;
                    const MAX_IP_RETRIES = 3;

                    async function attemptIPLocation() {
                        try {
                            locationInfo.textContent = `${LOCATION_MESSAGES.IP_LOADING} (å°è¯• ${ipRetryCount + 1}/${MAX_IP_RETRIES})`;
                            const response = await fetch('/get_ip_location');
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            const data = await response.json();

                            if (data.latitude && data.longitude) {
                                latitude = parseFloat(data.latitude);
                                longitude = parseFloat(data.longitude);
                                locationInfo.textContent = `æ‚¨çš„ä½ç½®ï¼š ${latitude.toFixed(4)}, ${longitude.toFixed(4)} (${data.city}, ${data.province} é€šè¿‡ IP)`;
                                currentLat = latitude;
                                currentLon = longitude;
                                hideManualLocationInput(); // éšè—æ‰‹åŠ¨è¾“å…¥æ¡†
                            } else {
                                throw new Error('IPå®šä½è¿”å›æ•°æ®æ— æ•ˆ');
                            }
                        } catch (error) {
                            console.error(`IPå®šä½é”™è¯¯ (å°è¯• ${ipRetryCount + 1}/${MAX_IP_RETRIES}):`, error);
                            if (ipRetryCount < MAX_IP_RETRIES - 1) {
                                ipRetryCount++;
                                setTimeout(attemptIPLocation, 1000);
                            } else {
                                console.error('IPå®šä½æœ€ç»ˆå¤±è´¥ï¼Œæ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥');
                                showManualLocationInput();
                            }
                        }
                    }

                    await attemptIPLocation();
                }

                // å¼€å§‹å®šä½æµç¨‹
                tryGeolocation();
            }

            async function getWeatherAIResponse(latitude, longitude, query, forecastDays) {
                try {
                    showLoading(); // Show loading animation before request
                    showResponse('', false); // Clear previous response, set isLoading to false as loading is handled by dedicated container
                    const modelType = document.querySelector('input[name="model"]:checked').value; // Get selected model
                    const response = await fetch('/get_weather_advice', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ latitude, longitude, query, forecast_days: forecastDays, model_type: modelType })
                    });

                    if (!response.ok) throw new Error(`HTTP é”™è¯¯ï¼çŠ¶æ€ç : ${response.status}`);

                    const data = await response.json();
                    showResponse(data.ai_response || data.error || 'ä»æœåŠ¡å™¨æ”¶åˆ°æ„å¤–çš„å“åº”ã€‚');
                } catch (error) {
                    console.error('è·å–å¤©æ°”å»ºè®®æ—¶å‡ºé”™:', error);
                    showResponse(`æ— æ³•è·å–å¤©æ°”å»ºè®®: ${error.message}`);
                } finally {
                    hideLoading(); // Hide loading animation after request (success or error)
                }
            }

            function handleSearch() {
                const query = document.getElementById('queryInput').value.trim();
                if (!query) {
                    showResponse("è¯·è¾“å…¥ä¸€ä¸ªé—®é¢˜ã€‚");
                    return;
                }
                if (typeof latitude === 'undefined' || typeof longitude === 'undefined') {
                    showResponse("ä½ç½®ä¿¡æ¯å°šæœªå¯ç”¨ï¼Œè¯·ç¨å€™ã€‚");
                    return;
                }
                // ç¼“å­˜ä½ç½®å’Œé¢„æµ‹å¤©æ•° (Cache location and forecast days)
                cachedLocation = { latitude, longitude };
                cachedForecastDays = parseInt(forecastDaysInput.value);
                getWeatherAIResponse(latitude, longitude, query, cachedForecastDays);
            }

            // Event Listeners
            themeToggle.addEventListener('click', toggleTheme);
            searchButton.addEventListener('click', handleSearch); // Attach to search button
            searchBar.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') handleSearch();
            });
            document.getElementById('getLocationBtn').addEventListener('click', () => {
                // Clear any existing location info
                locationInfo.textContent = LOCATION_MESSAGES.LOADING;
                // Reset the location values
                latitude = undefined;
                longitude = undefined;
                // Start the location process again
                getLocation();
            });

            // Example queries event listeners (Updated)
            exampleQueries.forEach(queryElement => {
                queryElement.addEventListener('click', function () {
                    searchBar.value = this.dataset.query;
                    searchBar.focus();
                    const days = this.dataset.days;
                    if (days) {
                        forecastDaysInput.value = days;
                        forecastDaysValueDisplay.textContent = days;
                        updateSliderBackground(forecastDaysInput);
                    }
                    // Add this line to show the clear button when using example queries
                    document.getElementById('clearSearch').classList.add('visible');
                });
            });


            // Initialize theme (Apply saved or automatic theme)
            const savedTheme = localStorage.getItem('theme');
            savedTheme ? setTheme(savedTheme) : applyAutomaticTheme();

            // åˆå§‹åŒ–ä½ç½®UIï¼Œä½†ä¸è‡ªåŠ¨è·å–ä½ç½®
            locationInfo.textContent = 'è¯·è¾“å…¥åŸå¸‚åç§°æˆ–ç‚¹å‡»ğŸ“è·å–å½“å‰ä½ç½®';

            // Forecast days slider (Slider functionality with visual update)
            function updateSliderBackground(slider) {
                const value = (slider.value - slider.min) / (slider.max - slider.min) * 100;
                slider.style.background = `linear-gradient(to right, var(--primary-color) 0%, var(--primary-color) ${value}%, #d3d3d3 ${value}%, #d3d3d3 100%)`;
            }

            forecastDaysInput.addEventListener('input', () => {
                forecastDaysValueDisplay.textContent = forecastDaysInput.value;
                updateSliderBackground(forecastDaysInput); // Update slider background on input
            });
            updateSliderBackground(forecastDaysInput); // Initial slider background update


            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    searchBar.focus();
                }
            });

            // Add error boundary
            window.onerror = function (msg, url, lineNo, columnNo, error) {
                console.error('Global error:', { msg, url, lineNo, columnNo, error });
                showResponse('åº”ç”¨ç¨‹åºå‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
                return false;
            };


            // Add analytics event tracking (optional - replace with your analytics code)
            const trackEvent = (eventName, eventData) => {
                if (window.gtag) {
                    gtag('event', eventName, eventData);
                }
            };

            // Add accessibility improvements
            const improveAccessibility = () => {
                // Add ARIA labels - already in place, can add more if needed
            };

            improveAccessibility();

            // Lazy load response container (Intersection Observer)
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1'; // Or any other lazy load effect
                        observer.unobserve(entry.target); // Optionally unobserve after loading
                    }
                });
            });

            if (responseContainer) {
                responseContainer.style.opacity = '0'; // Initially hide or style for lazy load
                observer.observe(responseContainer);
            }

            // Prefers reduced motion
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.documentElement.style.setProperty('--transition-speed', '0s');
            }

            // Add this to your existing JavaScript
            const searchInput = document.getElementById('queryInput');
            const clearButton = document.getElementById('clearSearch');

            // Show/hide clear button based on input content
            searchInput.addEventListener('input', () => {
                clearButton.classList.toggle('visible', searchInput.value.length > 0);
            });

            // Clear input when clear button is clicked
            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                clearButton.classList.remove('visible');
                searchInput.focus();
            });

            // æ·»åŠ æ‰‹åŠ¨ä½ç½®è¾“å…¥ç›¸å…³å‡½æ•°
            function showManualLocationInput() {
                const container = document.getElementById('manualLocationContainer');
                if (container) {
                    container.style.display = 'flex';
                }
            }

            function hideManualLocationInput() {
                const container = document.getElementById('manualLocationContainer');
                if (container) {
                    container.style.display = 'none';
                }
            }

            async function handleCitySubmit() {
                const cityInput = document.getElementById('cityInput');
                const city = cityInput.value.trim();
                
                if (!city) {
                    locationInfo.textContent = 'è¯·è¾“å…¥åŸå¸‚åç§°';
                    return;
                }

                try {
                    locationInfo.textContent = 'æ­£åœ¨è·å–åŸå¸‚ä½ç½®ä¿¡æ¯...';
                    const response = await fetch('/get_city_location', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ city: city })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }

                    latitude = parseFloat(data.latitude);
                    longitude = parseFloat(data.longitude);
                    currentLat = latitude;
                    currentLon = longitude;
                    
                    locationInfo.textContent = `æ‚¨çš„ä½ç½®ï¼š ${latitude.toFixed(4)}, ${longitude.toFixed(4)} (${city})`;
                    cityInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†ï¼Œæ–¹ä¾¿ä¸‹æ¬¡è¾“å…¥
                } catch (error) {
                    console.error('è·å–åŸå¸‚ä½ç½®å¤±è´¥:', error);
                    locationInfo.textContent = `æ— æ³•è·å–åŸå¸‚"${city}"çš„ä½ç½®ä¿¡æ¯ï¼Œè¯·é‡è¯•æˆ–è¾“å…¥å…¶ä»–åŸå¸‚`;
                }
            }

            // æ·»åŠ åŸå¸‚æäº¤ç›¸å…³çš„äº‹ä»¶ç›‘å¬
            document.getElementById('submitCity').addEventListener('click', handleCitySubmit);
            document.getElementById('cityInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleCitySubmit();
            });
            document.getElementById('getLocationBtn').addEventListener('click', getLocation);
        });

        // Add to existing scripts

        function showLoading() {
            document.querySelector('.loading-container').style.display = 'flex';
            document.getElementById('response-container').style.display = 'none';
        }

        function hideLoading() {
            document.querySelector('.loading-container').style.display = 'none';
            document.getElementById('response-container').style.display = 'block';
        }

        // Example usage in your API call:
        /*
        async function handleSearch() {
            showLoading();
            try {
                // Your API call here
                await fetchResponse();
            } finally {
                hideLoading();
            }
        }
        */
    </script>
</body>

</html>